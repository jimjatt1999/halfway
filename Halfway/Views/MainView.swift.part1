import SwiftUI
import MapKit
import Combine
import Contacts

struct MainView: View {
    @EnvironmentObject var locationManager: LocationManager
    @StateObject private var viewModel: HalfwayViewModel
    
    @State private var isLocationSearching = false
    @State private var searchFor: Int = 0 // Using an Int to represent the location index
    @State private var mapRegion = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: 0, longitude: 0), // Initialize with zeros, will update to user location
        span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
    )
    @State private var showingErrorAlert = false
    @State private var isExpanded = false
    @State private var resetLocations = false
    @State private var mapType: MKMapType = .standard
    @State private var draggedOffset: CGFloat = 0
    @State private var searchText = ""
    
    // For handling locations added from map
    @State private var locationFromMap: Location? = nil
    
    // Animation states for the title
    @State private var isTitleAnimating = false
    @State private var halfOffset: CGFloat = 0
    @State private var wayOffset: CGFloat = 0
    @State private var titleScale: CGFloat = 1.0
    @State private var titleOpacity: Double = 1.0
    
    // Minimum height for the results panel - increased for better initial visibility
    let minDragHeight: CGFloat = 550 // Changed from 450 to 550 for more screen coverage initially
    // Maximum height for the results panel (will be calculated from screen height)
    var maxDragHeight: CGFloat {
        UIScreen.main.bounds.height * 0.85
    }
    
    @StateObject private var cancellableStore = CancellableStore()
    
    // Add properties for loading animation
    @State private var currentSubtitleIndex = 0
    @State private var subtitleOpacity = 1.0
    @State private var loadingSubtitles = [
        "Finding the perfect middle ground...",
        "Calculating meeting points...",
        "Searching for common ground...",
        "Finding places in between...",
        "Connecting the dots...",
        "Somewhere in the middle...",
        "Splitting the difference...",
        "Making sure you don't have to go all the way...",
        "Doing math so you don't have to...",
        "Finding places where nobody has to drive too far...",
        "Calculating the exact center of your friendship...",
        "Using advanced algorithms to avoid arguments...",
        "Making sure it's fair for everyone...",
        "Balancing the universe perfectly, as all things should be...",
        "Convincing GPS satellites to work together...",
        "Teaching maps to understand compromise...",
        "The app equivalent of saying 'let's meet in the middle'...",
        "Drawing a line between you both and finding the good stuff...",
        "Creating peace and harmony through equidistant meetups..."
    ]
    
    // Tutorial tooltip state
    @State private var showTutorialManager = false
    
    // Anchors for tooltips
    @State private var mapExpandButtonAnchor: Anchor<CGPoint>? = nil
    @State private var addLocationButtonAnchor: Anchor<CGPoint>? = nil
    @State private var searchRadiusAnchor: Anchor<CGPoint>? = nil
    @State private var filterButtonAnchor: Anchor<CGPoint>? = nil
    
    // Add isFullScreen state variable to ResultsPanel
    @State private var isFullScreen = false
    
    init(viewModel: HalfwayViewModel = HalfwayViewModel(locationManager: LocationManager())) {
        _viewModel = StateObject(wrappedValue: viewModel)
        
        // Load last known location from UserDefaults if available
        if let savedLatitude = UserDefaults.standard.object(forKey: "lastMapLatitude") as? Double,
           let savedLongitude = UserDefaults.standard.object(forKey: "lastMapLongitude") as? Double {
            _mapRegion = State(initialValue: MKCoordinateRegion(
                center: CLLocationCoordinate2D(latitude: savedLatitude, longitude: savedLongitude),
                span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
            ))
        }
    }
    
    var body: some View {
        ZStack {
            // Map view with blur overlay when results are shown
            MapView(region: $mapRegion, 
                    locations: viewModel.locations,
                    midpoint: viewModel.midpoint,
                    places: viewModel.filteredPlaces,
                    searchRadius: viewModel.searchRadius,
                    selectedPlace: $viewModel.showingPlaceDetail,
                    isExpanded: isExpanded,
                    resetLocations: $resetLocations,
                    mapType: mapType)
                .edgesIgnoringSafeArea(.all)
            
            // Semi-transparent overlay when results are shown (creates subtle depth)
            if !isExpanded && !viewModel.filteredPlaces.isEmpty {
                Color.black.opacity(0.15)
                    .edgesIgnoringSafeArea(.all)
            }
            
            if !isExpanded {
                VStack(spacing: 0) {
                    // App title and control buttons
                    HStack {
                        // Animated title
                        HStack(spacing: 0) {
                            Text("Half")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .shadow(radius: 2)
                                .offset(x: halfOffset)
                                .scaleEffect(titleScale)
                                .opacity(titleOpacity)
                                
                            Text("way")
                                .font(.title)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .shadow(radius: 2)
                                .offset(x: wayOffset)
                                .scaleEffect(titleScale)
                                .opacity(titleOpacity)
                        }
                        .contentShape(Rectangle()) // Make the entire area tappable
                        .padding(.leading)
                        .onTapGesture {
                            animateTitle()
                        }
                        
                        Spacer()
                        
                        HStack(spacing: 16) {
                            // Map type toggle button
                            Button(action: {
                                mapType = mapType == .standard ? .satellite : .standard
                            }) {
                                Image(systemName: mapType == .standard ? "globe" : "map")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                            }
                            
                            // Midpoint navigation button
                            Button(action: {
                                if let midpoint = viewModel.midpoint {
                                    // Make sure to reset the user interaction flag immediately
                                    NotificationCenter.default.post(
                                        name: NSNotification.Name("ResetMapInteraction"),
                                        object: nil
                                    )
                                    
                                    // Set map region to focus on midpoint with instant animation
                                    // Use a more focused zoom level for better visibility
                                    mapRegion = MKCoordinateRegion(
                                        center: midpoint,
                                        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
                                    )
                                    
                                    // Show feedback with haptics
                                    let generator = UIImpactFeedbackGenerator(style: .medium)
                                    generator.impactOccurred()
                                }
                            }) {
                                Image(systemName: "location")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                            }
                            .disabled(viewModel.midpoint == nil)
                            .opacity(viewModel.midpoint == nil ? 0.5 : 1.0)
                            
                            // Expand button with anchor for tooltip
                            Button(action: {
                                withAnimation(.spring(duration: 0.3)) {
                                    isExpanded.toggle()
                                }
                                // Notify MapView about expanded state change
                                DispatchQueue.main.async {
                                    NotificationCenter.default.post(
                                        name: NSNotification.Name("MapExpandedStateChanged"),
                                        object: nil
                                    )
                                }
                            }) {
                                Image(systemName: "arrow.up.left.and.arrow.down.right")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                                    .anchorPreference(key: ViewAnchorKey.self, value: .center) { anchor in
                                        [ViewAnchorKey.ID.mapExpandButton: anchor]
                                    }
                            }
                        }
                        .padding(.trailing)
                    }
                    .padding(.top, 8)
                    
                    Spacer()
                    
                    // Content panel at the bottom
                    if (viewModel.midpoint == nil || 
                        (viewModel.filteredPlaces.isEmpty && viewModel.selectedCategory == nil && viewModel.noResultsReason == nil)) && 
                       viewModel.searchText.isEmpty && // Only show search panel when not actively searching
                       !viewModel.isSearching { // Make sure we're not in the middle of a search
                        // Redesigned floating search panel
                        searchPanel
                            .transition(.move(edge: .bottom).combined(with: .opacity))
                    } else {
                        // Improved results panel
                        ResultsPanel(
                            viewModel: viewModel,
                            resetLocations: $resetLocations,
                            mapRegion: $mapRegion,
                            isExpanded: $isExpanded,
                            dragOffset: $draggedOffset,
                            minHeight: minDragHeight,
                            maxHeight: maxDragHeight,
                            mapType: mapType,
                            searchText: $searchText
                        )
                        .transition(.opacity)
                        .animation(.spring(), value: viewModel.filteredPlaces)
                        .animation(.spring(), value: searchText)
                        .animation(.spring(), value: viewModel.noResultsReason)
                        // Add anchor for search radius slider
                        .anchorPreference(key: ViewAnchorKey.self, value: .center) { anchor in
                            [ViewAnchorKey.ID.searchRadius: anchor]
                        }
                    }
                }
            } else {
                // Expanded mode with compact controls
                VStack {
                    HStack {
                        Spacer()
                        
                        HStack(spacing: 16) {
                            // Map type toggle button
                            Button(action: {
                                mapType = mapType == .standard ? .satellite : .standard
                            }) {
                                Image(systemName: mapType == .standard ? "globe" : "map")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                            }
                            
                            // Midpoint navigation button
                            Button(action: {
                                if let midpoint = viewModel.midpoint {
                                    // Make sure to reset the user interaction flag immediately
                                    NotificationCenter.default.post(
                                        name: NSNotification.Name("ResetMapInteraction"),
                                        object: nil
                                    )
                                    
                                    // Set map region to focus on midpoint with instant animation
                                    // Use a more focused zoom level for better visibility
                                    mapRegion = MKCoordinateRegion(
                                        center: midpoint,
                                        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
                                    )
                                    
                                    // Show feedback with haptics
                                    let generator = UIImpactFeedbackGenerator(style: .medium)
                                    generator.impactOccurred()
                                }
                            }) {
                                Image(systemName: "location")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                            }
                            .disabled(viewModel.midpoint == nil)
                            .opacity(viewModel.midpoint == nil ? 0.5 : 1.0)
                            
                            // Collapse button
                            Button(action: {
                                withAnimation(.spring(duration: 0.3)) {
                                    isExpanded.toggle()
                                }
                            }) {
                                Image(systemName: "arrow.down.right.and.arrow.up.left")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        Circle()
                                            .fill(Color.black.opacity(0.7))
                                            .shadow(color: Color.black.opacity(0.2), radius: 4, x: 0, y: 2)
                                    )
                            }
                        }
                        .padding(.trailing)
                    }
                    .padding(.top, 8)
                    
                    Spacer()
                }
            }
            
            // Update loading overlay with enhanced animations
            if viewModel.isSearching {
                ZStack {
                    // Blur background effect
                    BlurView(style: .systemMaterialDark)
                        .opacity(0.95)
                        .edgesIgnoringSafeArea(.all)
                    
                    // Dark overlay for better text contrast
                    Color.black.opacity(0.5)
                        .edgesIgnoringSafeArea(.all)
                }
                .transition(.opacity.animation(.easeInOut(duration: 0.3)))
                
                VStack(spacing: 20) {
                    // Animated title for loading state
                    HStack(spacing: 0) {
                        Text("Half")
                            .font(.system(size: 36, weight: .bold))
                            .foregroundColor(.white)
                            .offset(x: halfOffset)
                            .scaleEffect(titleScale)
                            .opacity(titleOpacity)
                            
                        Text("way")
                            .font(.system(size: 36, weight: .bold))
                            .foregroundColor(.white)
                            .offset(x: wayOffset)
                            .scaleEffect(titleScale)
                            .opacity(titleOpacity)
                    }
                    .padding(.bottom, 5)
                    
                    // Add a subtitle that cycles through different alternatives
                    Text(loadingSubtitles[currentSubtitleIndex])
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(.white.opacity(0.9))
                        .opacity(subtitleOpacity)
                        .transition(.opacity.combined(with: .move(edge: .trailing)))
                        .id("subtitle-\(currentSubtitleIndex)") // Force view recreation for animation
                    
                    // Improved progress indicator with pulsing animation
                    ProgressView()
                        .scaleEffect(1.5)
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .padding(.top, 10)
                        .modifier(PulseAnimation())
                }
                .transition(.opacity.combined(with: .scale(scale: 0.95)))
                .onAppear {
                    // Start animations when loading begins
                    animateLoadingTitle()
                    startSubtitleAnimation()
                }
            }
            
            // Add the tutorial manager with smooth transitions
            if showTutorialManager {
                FloatingTutorialManager(
                    mapExpandAnchor: mapExpandButtonAnchor,
                    addLocationAnchor: addLocationButtonAnchor,
                    filterResultsAnchor: filterButtonAnchor,
                    searchRadiusAnchor: searchRadiusAnchor
                )
                .transition(.opacity.animation(.easeInOut(duration: 0.5)))
            }
        }
        
        // Function to animate the loading subtitle rotation
        private func startSubtitleAnimation() {
            // Animate subtitle changes
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                guard viewModel.isSearching else { return }
                
                withAnimation(.easeInOut(duration: 0.6)) {
                    subtitleOpacity = 0
                }
                
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                    currentSubtitleIndex = (currentSubtitleIndex + 1) % loadingSubtitles.count
                    
                    withAnimation(.easeInOut(duration: 0.6)) {
                        subtitleOpacity = 1.0
                    }
                    
                    // Continue cycle if still loading
                    if viewModel.isSearching {
                        startSubtitleAnimation()
                    }
                }
            }
        }
        
        // Create a pulse animation for the loading spinner
        struct PulseAnimation: ViewModifier {
            @State private var pulsate = false
            
            func body(content: Content) -> some View {
                content
                    .scaleEffect(pulsate ? 1.05 : 1.0)
                    .opacity(pulsate ? 1.0 : 0.9)
                    .onAppear {
                        withAnimation(Animation.easeInOut(duration: 1.2).repeatForever(autoreverses: true)) {
                            pulsate = true
                        }
                    }
            }
        }
        
        // Add a SlideTransition modifier for Results panel
        struct SlideTransition: ViewModifier {
            var isActive: Bool
            
            func body(content: Content) -> some View {
                content
                    .offset(y: isActive ? 0 : 30)
                    .opacity(isActive ? 1.0 : 0.0)
                    .animation(.spring(response: 0.4, dampingFraction: 0.8), value: isActive)
            }
        }
        
        .sheet(isPresented: $isLocationSearching) {
            LocationSearchView(searchText: "", onLocationSelected: { location in
                if searchFor < viewModel.locations.count {
                    viewModel.setLocation(at: searchFor, to: location)
                } else {
                    viewModel.addLocation(location)
                }
                isLocationSearching = false
            }, onUseCurrentLocation: {
                viewModel.useCurrentLocation(at: searchFor)
                isLocationSearching = false
            })
        }
        .sheet(item: $viewModel.showingPlaceDetail) { place in
            PlaceDetailView(place: place, locations: viewModel.locations)
        }
        .sheet(item: $locationFromMap) { location in
            // Confirmation sheet for adding a location from the map
            VStack(spacing: 16) {
                Text("Add Location")
                    .font(.headline)
                    .padding(.top, 20)
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("Location Name:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    Text(location.name)
                        .font(.body)
                        .padding(12)
                        .background(Color(UIColor.secondarySystemBackground))
                        .cornerRadius(8)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                .padding(.horizontal)
                
                HStack(spacing: 20) {
                    Button("Cancel") {
                        locationFromMap = nil
                    }
                    .buttonStyle(BorderedButtonStyle())
                    .controlSize(.large)
                    
                    Button("Add to Location \(viewModel.locations.count + 1)") {
                        // Add the location to the proper slot based on current count
                        let index = viewModel.locations.count
                        if index < 2 {
                            // Use legacy methods for first two locations for backward compatibility
                            if index == 0 {
                                viewModel.setLocation1(location)
                            } else {
                                viewModel.setLocation2(location)
                            }
                        } else {
                            // Use the generic method for additional locations
                            viewModel.addLocation(location)
                        }
                        
                        // Clear the locationFromMap to dismiss the sheet
                        locationFromMap = nil
                        
                        // Update the map region to focus on the added location
                        withAnimation {
                            mapRegion = MKCoordinateRegion(
                                center: location.coordinate,
                                span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
                            )
                        }
                    }
                    .buttonStyle(BorderedProminentButtonStyle())
                    .controlSize(.large)
                    .tint(.indigo)
                }
                .padding(.horizontal)
                .padding(.top, 8)
                .padding(.bottom, 20)
            }
            .frame(height: 220) // Fixed height instead of presentation detents
        }
        .alert(viewModel.errorMessage ?? "An error occurred", isPresented: .constant(viewModel.errorMessage != nil)) {
            Button("OK") {
                viewModel.errorMessage = nil
            }
        }
        .onAppear {
            // Immediately request user location
            locationManager.requestLocation()
            
            // Set map region to user location when it becomes available
            if let userLocation = locationManager.userLocation?.coordinate {
                mapRegion = MKCoordinateRegion(
                    center: userLocation,
                    span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
                )
                
                // Save this location to UserDefaults
                UserDefaults.standard.set(userLocation.latitude, forKey: "lastMapLatitude")
                UserDefaults.standard.set(userLocation.longitude, forKey: "lastMapLongitude")
            } else if UserDefaults.standard.object(forKey: "lastMapLatitude") == nil {
                // Only default to (0,0) if we don't have any saved location
                mapRegion = MKCoordinateRegion(
                    center: CLLocationCoordinate2D(latitude: 0, longitude: 0),
                    span: MKCoordinateSpan(latitudeDelta: 50, longitudeDelta: 50)
                )
            }
            
            // Add publisher to observe midpoint changes
            viewModel.$midpoint
                .compactMap { $0 } // Only proceed when midpoint is not nil
                .sink { midpoint in
                    // Update map region when midpoint changes
                    withAnimation {
                        self.mapRegion = MKCoordinateRegion(
                            center: midpoint,
                            span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
                        )
                    }
                }
                .store(in: &cancellableStore.set)
            
            // Set up notification observers
            NotificationCenter.default.addObserver(
                forName: NSNotification.Name("AddLocationFromMap"), 
                object: nil, 
                queue: .main
            ) { notification in
                if let location = notification.object as? Location {
                    // Only show the sheet if we have room for more locations
                    if viewModel.canAddLocation {
                        locationFromMap = location
                    } else {
                        // Show a temporary notification that we've reached the max number of locations
                        let generator = UINotificationFeedbackGenerator()
                        generator.notificationOccurred(.warning)
                        
                        // Show a toast message
                        showToast(message: "Maximum of 5 locations reached")
                    }
                }
            }
            
            if viewModel.locations.isEmpty {
                animateTitle()
            }
            
            // Delay showing tutorials until after the app is fully loaded
            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                showTutorialManager = true
            }
        }
        .onChange(of: locationManager.userLocation) { newValue in
            // Update map region when user location changes and we don't have existing locations set
            if viewModel.locations.isEmpty, let userLocation = newValue?.coordinate {
                mapRegion = MKCoordinateRegion(
                    center: userLocation,
                    span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
                )
                
                // Save this location to UserDefaults
                UserDefaults.standard.set(userLocation.latitude, forKey: "lastMapLatitude") 
                UserDefaults.standard.set(userLocation.longitude, forKey: "lastMapLongitude")
            }
        }
        .onPreferenceChange(ViewAnchorKey.self) { preferences in
            self.mapExpandButtonAnchor = preferences[.mapExpandButton]
            self.addLocationButtonAnchor = preferences[.addLocationButton]
            self.searchRadiusAnchor = preferences[.searchRadius]
            self.filterButtonAnchor = preferences[.filterButton]
        }
    }
    
    // Function to handle the title animation
    func animateTitle() {
        guard !isTitleAnimating else { return }
        
        isTitleAnimating = true
        titleOpacity = 1.0
        
        // First animation - separate the words
        withAnimation(.spring(response: 0.4, dampingFraction: 0.7, blendDuration: 0.2)) {
            halfOffset = -30
            wayOffset = 30
            titleScale = 1.2
        }
        
        // Second animation - bounce back with slight overshoot
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.6, blendDuration: 0.1)) {
                halfOffset = -5
                wayOffset = 5
            }
        }
        
        // Third animation - return to original state
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.8) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7, blendDuration: 0.1)) {
                halfOffset = 0
                wayOffset = 0
                titleScale = 1.0
            }
            
            // Reset animation state after animation completes
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.2) {
                isTitleAnimating = false
            }
        }
    }
    
    // Add animations to category filters
    private var categoryFilters: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 10) {
                ForEach(PlaceCategory.allCases, id: \.self) { category in
                    let isSelected = viewModel.selectedCategory == category
                    Button(action: {
                        withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                            viewModel.filterByCategory(category)
                        }
                    }) {
                        VStack(spacing: 6) {
                            Image(systemName: category.iconName)
                                .font(.system(size: isSelected ? 18 : 16))
                                .foregroundColor(isSelected ? .white : .secondary)
                                .frame(width: 40, height: 40)
                                .background(
                                    Circle()
                                        .fill(isSelected ? Color.accentColor : Color(.systemGray6))
                                )
                                .overlay(
                                    Circle()
                                        .stroke(isSelected ? Color.accentColor : Color.clear, lineWidth: 2)
                                        .scaleEffect(isSelected ? 1.1 : 1.0)
                                        .opacity(isSelected ? 0.7 : 0)
                                )
                                .scaleEffect(isSelected ? 1.1 : 1.0)
                            
                            Text(category.displayName)
                                .font(.caption)
                                .foregroundColor(isSelected ? .primary : .secondary)
                        }
                    }
                    .buttonStyle(ScaleButtonStyle())
                    .contentShape(Rectangle())
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 10)
            .padding(.bottom, 8)
        }
    }
    
    // Redesigned floating search panel with animations
    var searchPanel: some View {
        VStack(spacing: 16) {
            // Modern card design with shadow and blur background
            VStack(spacing: 20) {
                Text("Find places halfway between locations")
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.primary)
                
                // Location inputs with better styling
                VStack(spacing: 12) {
                    ForEach(0..<min(viewModel.locations.count + 1, viewModel.canAddLocation ? viewModel.locations.count + 1 : viewModel.locations.count), id: \.self) { index in
                        let isNewLocation = index == viewModel.locations.count
                        let location = isNewLocation ? nil : viewModel.locations[index]
                        
                        locationInputRow(
                            index: index,
                            location: location,
                            isNewLocation: isNewLocation
                        )
                        .transition(.asymmetric(
                            insertion: .scale(scale: 0.95).combined(with: .opacity).animation(.spring(response: 0.4, dampingFraction: 0.7)),
                            removal: .opacity.animation(.easeOut(duration: 0.2))
                        ))
                    }
                }
                .animation(.spring(response: 0.4, dampingFraction: 0.7), value: viewModel.locations.count)
                
                // Find Meeting Places button with clean Apple-style
                FindMeetingPlacesButton(isDisabled: viewModel.locations.isEmpty) {
                    // Only search when button is explicitly clicked
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
                        viewModel.searchPlacesAroundMidpoint()
                    }
                }
            }
            .padding(20)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(UIColor.systemBackground).opacity(0.95))
                    .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 5)
            )
            .padding(.horizontal, 20)
            .padding(.bottom, 25)
        }
        .transition(.asymmetric(
            insertion: .move(edge: .bottom).combined(with: .opacity),
            removal: .opacity
        ))
    }
    
    // Add a custom button style for subtle scale animations
    struct ScaleButtonStyle: ButtonStyle {
        func makeBody(configuration: Configuration) -> some View {
            configuration.label
                .scaleEffect(configuration.isPressed ? 0.92 : 1)
                .animation(.spring(response: 0.3, dampingFraction: 0.7), value: configuration.isPressed)
        }
    }
    
    // FindMeetingPlacesButton with animated feedback
    struct FindMeetingPlacesButton: View {
        var isDisabled: Bool
        var action: () -> Void
        @State private var isPressed = false
        
        var body: some View {
            Button(action: {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                    isPressed = true
                    
                    // Provide haptic feedback
                    let generator = UIImpactFeedbackGenerator(style: .medium)
                    generator.impactOccurred()
                    
                    // Reset pressed state after a delay
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                            isPressed = false
                        }
                        action()
                    }
                }
            }) {
                HStack {
                    Image(systemName: "mappin.and.ellipse")
                        .font(.headline)
                        .padding(.trailing, 2)
                    
                    Text("Find Meeting Places")
                        .font(.headline)
                }
                .foregroundColor(.white)
                .frame(height: 50)
                .frame(maxWidth: .infinity)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(isDisabled ? Color.gray : Color.accentColor)
                        .shadow(color: isDisabled ? Color.clear : Color.accentColor.opacity(0.4), radius: isPressed ? 2 : 5, x: 0, y: isPressed ? 1 : 3)
                )
                .scaleEffect(isPressed ? 0.97 : 1.0)
            }
            .disabled(isDisabled)
            .opacity(isDisabled ? 0.6 : 1.0)
        }
    }
    
    // Location input row with add/remove capabilities
    func locationInputRow(index: Int, location: Location?, isNewLocation: Bool) -> some View {
        HStack {
            // Location icon with index number 
            ZStack {
                Circle()
                    .fill(locationColor(for: index))
                    .frame(width: 32, height: 32)
                
                if isNewLocation {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                } else {
                    Text("\(index + 1)")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                }
            }
            
            if isNewLocation {
                // "Add location" button
                Button(action: {
                    isLocationSearching = true
                    searchFor = index
                }) {
                    HStack {
                        Text(index == 0 ? "Add a location" : "Add another location")
                            .font(.system(size: 15))
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .contentShape(Rectangle())
                    .frame(height: 36)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color(UIColor.secondarySystemBackground))
                    )
                }
            } else {
                // Location input button
                Button(action: {
                    searchFor = index
                    isLocationSearching = true
                }) {
                    HStack {
                        Text(location?.name ?? "Enter location")
                            .lineLimit(1)
                            .font(.system(size: 15))
                            .foregroundColor(location != nil ? .primary : .secondary)
                        Spacer()
                    }
                    .contentShape(Rectangle())
                    .frame(height: 36)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color(UIColor.secondarySystemBackground))
                    )
                }
                
                // Menu for location options
                Menu {
                    Button(action: {
                        searchFor = index
                        isLocationSearching = true
                    }) {
                        Label("Change location", systemImage: "mappin")
                    }
                    
                    Button(action: {
                        viewModel.useCurrentLocation(at: index)
                    }) {
                        Label("Use current location", systemImage: "location.fill")
                    }
                    
                    // Allow removing any location
                    Button(role: .destructive, action: {
                        withAnimation {
                            viewModel.removeLocation(at: index)
                        }
                    }) {
                        Label("Remove", systemImage: "trash")
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                        .foregroundColor(.gray)
                        .font(.system(size: 20))
                }
                .padding(.leading, 4)
            }
        }
    }
    
    // Helper to get location color based on index
    func locationColor(for index: Int) -> Color {
        let colors: [Color] = [.blue, .green, .purple, .orange, .pink]
        return index < colors.count ? colors[index] : .gray
    }
    
    // Reusable location input button with improved styling (keeping for backward compatibility)
    func locationInputButton(icon: String, iconColor: Color, text: String, hasValue: Bool, action: @escaping () -> Void, clearAction: @escaping () -> Void) -> some View {
        HStack {
            Image(systemName: icon)
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(iconColor)
                .frame(width: 32, height: 32)
                .background(iconColor.opacity(0.1))
                .clipShape(Circle())
            
            Button(action: action) {
                HStack {
                    Text(text)
                        .lineLimit(1)
                        .font(.system(size: 15))
                        .foregroundColor(hasValue ? .primary : .secondary)
                        .padding(.leading, 8)
                    Spacer()
                }
                .contentShape(Rectangle())
                .frame(height: 36)
                .padding(.horizontal, 12)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color(UIColor.secondarySystemBackground))
                )
            }
            
            if hasValue {
                Button(action: clearAction) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                        .font(.system(size: 20))
                }
                .padding(.horizontal, 8)
            }
        }
    }
    
    // Add a helper function to calculate region that fits all points
    private func calculateRegion(for coordinates: [CLLocationCoordinate2D]) -> MKCoordinateRegion {
        guard !coordinates.isEmpty else { 
            return mapRegion 
        }
        
        var minLat = coordinates[0].latitude
        var maxLat = coordinates[0].latitude
        var minLon = coordinates[0].longitude
        var maxLon = coordinates[0].longitude
        
        for coordinate in coordinates {
            minLat = min(minLat, coordinate.latitude)
            maxLat = max(maxLat, coordinate.latitude)
            minLon = min(minLon, coordinate.longitude)
            maxLon = max(maxLon, coordinate.longitude)
        }
        
        let center = CLLocationCoordinate2D(
            latitude: (minLat + maxLat) / 2,
            longitude: (minLon + maxLon) / 2
        )
        
        // Add padding
        let latPadding = (maxLat - minLat) * 1.3
        let lonPadding = (maxLon - minLon) * 1.3
        
        // Ensure minimum span size
        let latDelta = max(latPadding, 0.02)
        let lonDelta = max(lonPadding, 0.02)
        
        return MKCoordinateRegion(
            center: center,
            span: MKCoordinateSpan(latitudeDelta: latDelta, longitudeDelta: lonDelta)
        )
    }
    
    // Helper to find the MapView coordinator
    private func findMapView() -> MapView.Coordinator? {
        // This is a shortcut to access the MapView coordinator directly
        // In a real app, you might want to use a more robust approach
